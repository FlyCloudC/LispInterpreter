3.1
(define pi 3.14) ; 给 3.14 起名为 pi
(* 2 pi 10) ; 相当于 (* 2 3.14 10)
(define C (* 2 pi 10)) ; 计算半径为 10 的圆的周长，起名为 C
---

3.2
(define (square x) (* x x))
(square 5) ; 相当于 (* 5 5)，得到 25
---

4.1
(+ 2 3) ; 这是一个形如 ([f] [x1] [x2]) 的组合式
; [f] 为 +，[x1] 为 2，[x2] 为 3
; 2 和 3 已经是值了，不用再化简，所以 [v1] 为 2，[v2] 为 3
; + 是语言自带的过程，于是按照加法的规则计算，得到 5
---

4.2
(define (square x) (* x x)) ; 定义一个过程 square

(square (+ 2 3)) ; 这是一个形如 ([f] [x1]) 的组合式
; [f] 为 square，[x1] 为 (+ 2 3)
; 先化简 (+ 2 3) ，具体过程如例1，得到 5, 记为 [v1]
; square 是先前定义的过程，于是先查看 square 的定义：
; (define (square x) (* x x))
; 这里 [a1] 为 x，[body] 为 (* x x)
; 将 [body]  中出现的 [a1] 替换为 [v1]，得到新的表达式 [body']，也就是
; 将 (* x x) 中出现的 x    替换为 5   ，得到新的表达式 (* 5 5)
; 所以 (square (+ 2 3)) 化简成 (* 5 5)
---

5.1
(define (fact n)
  (if (= n 1)
      1
      (* n (fact (- n 1)))))
---

5.2
(fact 3)
; 代入 fact 的定义
(if (= 3 1)
    1
    (* 3 (fact (- 3 1))))
; 由于 (= 3 1) 为 #f，所以 if表达式 化简成 后一个分支
(* 3 (fact (- 3 1)))
;
(* 3 (fact 2))
; 代入 fact 的定义
(* 3 (if (= 2 1)
         1
         (* 2 (fact (- 2 1)))))
; 由于 (= 2 1) 为 #f，所以 if表达式 化简成 后一个分支
(* 3
   (* 2 (fact (- 2 1))))
;
(* 3
   (* 2 (fact 1)))
; 代入 fact 的定义
(* 3
   (* 2
      (if (= 1 1)
          1
          (* 1 (fact (- 1 1))))))
; 由于 (= 1 1) 为 #t，所以 if表达式 化简成 前一个分支
(* 3
   (* 2
      1))
;
6
